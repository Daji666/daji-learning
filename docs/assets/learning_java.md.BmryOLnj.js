import{_ as i,c as a,o as n,ag as p}from"./chunks/framework.DLYFp6gQ.js";const g=JSON.parse('{"title":"Java学习","description":"","frontmatter":{},"headers":[],"relativePath":"learning/java.md","filePath":"learning/java.md","lastUpdated":1744357049000}'),t={name:"learning/java.md"};function h(l,s,k,e,r,d){return n(),a("div",null,s[0]||(s[0]=[p(`<h1 id="java学习" tabindex="-1">Java学习 <a class="header-anchor" href="#java学习" aria-label="Permalink to &quot;Java学习&quot;">​</a></h1><p>这里记录Java的学习内容。</p><h2 id="_1-java入门" tabindex="-1">1.Java入门 <a class="header-anchor" href="#_1-java入门" aria-label="Permalink to &quot;1.Java入门&quot;">​</a></h2><p><strong>学习套路:</strong> 这个技术是什么？ 这个技术可以解决什么问题？ 这个技术怎么应用？ 这个技术在使用中有什么注意细节？</p><p>平台:JavaSE(基础) JavaEE(企业服务端开发) JavaME(移动设备应用，较少)</p><p>如何使用:安装JDK，配置环境变量 JDK8 11 21</p><p>开发平台:IDEA</p><p><strong>常用快捷键:</strong> main/psvm sout 快捷键入相关代码 CTRL+D 复制当前行到下一行 CTRL+X 剪切当前行 CTRL+ALT+L 格式化代码 ALT+SHIFT+↑/↓ 上下移动代码 Ctrl+/ Ctrl+Shift+/ 单行/多行注释 / /* /**三种注释(单行 多行 文档)</p><h2 id="_2-常用api" tabindex="-1">2.常用API <a class="header-anchor" href="#_2-常用api" aria-label="Permalink to &quot;2.常用API&quot;">​</a></h2><p><strong>1.String操作字符串</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取字符串长度</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串转字符数组</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> charAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 提取字符串某个索引位置的字符</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object anObject) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 判断字符串内容</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equalsIgnoreCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String aString) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 判断字符串内容(忽略大小写)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> begin,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取部分字符串</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target,replacement)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 替换字符串</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CharSequence s)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 判断是否包含</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startWith</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">endsWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string prefix)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 判断字符串以什么开头/结尾</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String regax)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串按括号中的内容切割</span></span></code></pre></div><p><strong>注意事项</strong> 1.String的对象是不可变字符串对象，会在堆内存的字符串常量池存储。 2.&quot; &quot;定义的相同字符串的地址相同，只会产生一个对象，new定义的相同字符串地址不同，每new一次会产生一次新的对象</p><p><strong>2.ArrayList 集合</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ArrayList list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">void add(int index,E element) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 插入数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 根据索引获取数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取集合大小</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 根据索引删除数据，返回被删除的数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object o) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接删除数据，返回真假，默认删第一个出现的</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index,E element) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改某个索引位置出现的数据，返回修改前的数据</span></span></code></pre></div><h2 id="_3-javase进阶" tabindex="-1">3.JavaSE进阶 <a class="header-anchor" href="#_3-javase进阶" aria-label="Permalink to &quot;3.JavaSE进阶&quot;">​</a></h2><p>一.面向对象特征</p><p>封装-继承-多态</p><p>二.继承(extends) 让一个子类继承一个父类，二者具有公共属性和行为。 优点:提高代码复用性，建立类与类的关系</p><p>public class 子类 extends 父类{</p><p>} <strong>特点:</strong> 1.只支持单继承，不支持多继承，但可以多层继承</p><p>2.子类方法访问一个变量/方法 规则:就近原则(优先找子类，然后找父类) 局部变量直接访问 本类成员变量，使用this访问 父类成员变量，使用super访问</p><p>三.方法重写</p><p>发生在父子类(继承)中，子类的方法和父类一模一样 子类需要父类的功能，但父类的功能不完全满足需求</p><p><strong>注意事项</strong> 重写方法的名称和形参列表必须和被重写方法名和参数列表一致 私有方法不能被重写 子类重写父类方法时，子类访问权限要大于等于父类方法权限</p><p><strong>@Override</strong> 注解 检查是否有要重写的方法存在(检查语法)</p><p>三.抽象类</p><p>用abstract修饰的类</p><p>abstract修饰且没有具体实现的方法为抽象方法（必须写在抽象类中）</p><p>场景:父类定义一个方法时，但子类每个方法实现的逻辑都不一样</p><p>注意:子类必须重写抽象类中所有的抽象方法</p><p><strong>四.设计模式</strong></p><p>设计模式，就是一种解决开发中某个问题的方案</p><p>模板设计模式:把抽象类整体看作一个模板，模板中不能决定的东西定义为抽象方法，让使用模板的类(继承抽象类的类)去重写抽象方法实现需求</p><p>五.匿名对象 没有对象名接收的对象称为匿名对象</p><p>使用方式: 1.直接调用成员方法 2.直接当作方法参数传递 3.直接当作返回值</p><h2 id="第四部分" tabindex="-1">第四部分 <a class="header-anchor" href="#第四部分" aria-label="Permalink to &quot;第四部分&quot;">​</a></h2><p>44444444444</p>`,37)]))}const o=i(t,[["render",h]]);export{g as __pageData,o as default};
